// Generated by CoffeeScript 1.6.3
(function() {
  var Base, Helpers, Q, async, fs, path;

  Helpers = require('./Helpers');

  path = require('path');

  fs = require('fs');

  Q = require('q');

  async = require('async');

  Base = (function() {
    Base.prototype.directory = null;

    Base.prototype.recursive = false;

    Base.prototype.excludes = null;

    Base.prototype.filters = null;

    Base.prototype.systemFiles = false;

    Base.prototype.up = false;

    Base.prototype._findFirst = false;

    function Base(directory) {
      directory = path.resolve(directory);
      if (!fs.statSync(directory).isDirectory()) {
        throw new Error("Path " + directory + " is not directory");
      }
      this.directory = directory;
      this.excludes = [];
      this.filters = [];
    }

    Base.mock = function(tree, info) {
      var FS;
      if (tree == null) {
        tree = {};
      }
      if (info == null) {
        info = {};
      }
      FS = require('fs-mock');
      fs = new FS(tree, info);
      return fs;
    };

    Base.restore = function() {
      return fs = require('fs');
    };

    Base.prototype.recursively = function(recursive) {
      this.recursive = recursive != null ? recursive : true;
      return this;
    };

    Base.prototype.exclude = function(excludes, exactly) {
      var exclude, result, _i, _len;
      if (exactly == null) {
        exactly = false;
      }
      if (typeof excludes === 'string') {
        excludes = [excludes];
      }
      result = [];
      for (_i = 0, _len = excludes.length; _i < _len; _i++) {
        exclude = excludes[_i];
        if (exactly) {
          exclude = "<^>" + exclude + "<$>";
        }
        result.push(Helpers.normalizePattern(exclude));
      }
      this.excludes = this.excludes.concat(result);
      return this;
    };

    Base.prototype.showSystemFiles = function(systemFiles) {
      this.systemFiles = systemFiles != null ? systemFiles : true;
      return this;
    };

    Base.prototype.lookUp = function(up) {
      this.up = up != null ? up : true;
      return this;
    };

    Base.prototype.findFirst = function(_findFirst) {
      this._findFirst = _findFirst != null ? _findFirst : true;
      return this;
    };

    Base.prototype.filter = function(fn) {
      this.filters.push(fn);
      return this;
    };

    Base.prototype.getPathsSync = function(type, mask, dir) {
      var err, paths, read, result, stats, _i, _len, _path;
      if (type == null) {
        type = 'all';
      }
      if (mask == null) {
        mask = null;
      }
      if (dir == null) {
        dir = this.directory;
      }
      paths = [];
      try {
        read = fs.readdirSync(dir);
      } catch (_error) {
        err = _error;
        if (this._findFirst === true) {
          return null;
        }
        return paths;
      }
      for (_i = 0, _len = read.length; _i < _len; _i++) {
        _path = read[_i];
        _path = path.join(dir, _path);
        if (!this.checkExcludes(_path) || !this.checkSystemFiles(_path)) {
          continue;
        }
        try {
          stats = fs.statSync(_path);
        } catch (_error) {
          err = _error;
          continue;
        }
        switch (this.checkFile(_path, stats, mask, type)) {
          case 0:
            continue;
          case 1:
            if (this._findFirst === true) {
              return _path;
            }
            paths.push(_path);
        }
        if (stats.isDirectory() && this.recursive === true) {
          result = this.getPathsSync(type, mask, _path);
          if (this._findFirst === true && typeof result === 'string') {
            return result;
          } else if (this._findFirst === true && result === null) {
            continue;
          } else {
            paths = paths.concat(result);
          }
        }
      }
      if (this._findFirst === true) {
        return null;
      } else {
        return paths;
      }
    };

    Base.prototype.getPathsAsync = function(fn, type, mask, dir) {
      var paths,
        _this = this;
      if (type == null) {
        type = 'all';
      }
      if (mask == null) {
        mask = null;
      }
      if (dir == null) {
        dir = this.directory;
      }
      paths = [];
      return fs.readdir(dir, function(err, read) {
        var files, nextPaths, _i, _len, _path;
        if (err) {
          return fn(_this._findFirst === true ? null : paths);
        } else {
          nextPaths = [];
          for (_i = 0, _len = read.length; _i < _len; _i++) {
            _path = read[_i];
            _path = path.join(dir, _path);
            if (!_this.checkExcludes(_path) || !_this.checkSystemFiles(_path)) {
              continue;
            }
            nextPaths.push(_path);
          }
          files = {};
          return async.eachSeries(nextPaths, function(item, cb) {
            return fs.stat(item, function(err, stats) {
              if (!err) {
                files[item] = stats;
              }
              return cb();
            });
          }, function() {
            var file, stats, subDirectories;
            subDirectories = [];
            for (file in files) {
              stats = files[file];
              switch (_this.checkFile(file, stats, mask, type)) {
                case 0:
                  continue;
                case 1:
                  if (_this._findFirst === true) {
                    fn(file);
                    return null;
                  }
                  paths.push(file);
              }
              if (stats.isDirectory() && _this.recursive === true) {
                subDirectories.push(file);
              }
            }
            if (subDirectories.length === 0) {
              return fn(_this._findFirst === true ? null : paths);
            } else {
              return async.eachSeries(subDirectories, function(item, cb) {
                return _this.getPathsAsync(function(result) {
                  if (_this._findFirst === true && typeof result === 'string') {
                    fn(result);
                    return cb(new Error('Fake error'));
                  } else if (_this._findFirst === true && result === null) {
                    return cb();
                  } else {
                    paths = paths.concat(result);
                    return cb();
                  }
                }, type, mask, item);
              }, function(err) {
                if (!err) {
                  return fn(paths);
                }
              });
            }
          });
        }
      });
    };

    Base.prototype.checkExcludes = function(_path) {
      var exclude, _i, _len, _ref;
      _ref = this.excludes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        exclude = _ref[_i];
        if ((new RegExp(exclude)).test(_path)) {
          return false;
        }
      }
      return true;
    };

    Base.prototype.checkSystemFiles = function(_path) {
      if (this.systemFiles === false) {
        if (path.basename(_path)[0] === '.' || _path.match(/~$/) !== null) {
          return false;
        }
      }
      return true;
    };

    Base.prototype.checkFilters = function(_path, stats) {
      var filter, _i, _len, _ref;
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        filter = _ref[_i];
        if (!filter(stats, _path)) {
          return false;
        }
      }
      return true;
    };

    Base.prototype.checkFile = function(_path, stats, mask, type) {
      if (type === 'all' || (type === 'files' && stats.isFile()) || (type === 'directories' && stats.isDirectory())) {
        if (mask === null || (mask !== null && (new RegExp(mask, 'g')).test(_path))) {
          if (!this.checkFilters(_path, stats)) {
            return 0;
          }
          return 1;
        }
      }
      return 2;
    };

    Base.prototype.getPathsFromParentsSync = function(mask, type) {
      var Finder, breakAtEnd, finder, found, i, parentPath, parentPaths, previous, result, _i, _len;
      if (mask == null) {
        mask = null;
      }
      if (type == null) {
        type = 'all';
      }
      Finder = require('./Finder');
      parentPaths = Helpers.expandPath(this.directory);
      result = [];
      previous = null;
      breakAtEnd = false;
      for (i = _i = 0, _len = parentPaths.length; _i < _len; i = ++_i) {
        parentPath = parentPaths[i];
        if (this.up === true) {

        } else if (typeof this.up === 'string' && this.up === parentPath) {
          breakAtEnd = true;
        } else if (typeof this.up === 'number' && this.up <= i) {
          break;
        }
        finder = new Finder(parentPath);
        finder.recursive = this.recursive;
        finder.excludes = this.excludes;
        finder.filters = this.filters;
        finder.systemFiles = this.systemFiles;
        finder._findFirst = this._findFirst === true;
        if (previous !== null) {
          finder.exclude(previous, true);
        }
        found = finder.getPathsSync(type, mask);
        if (this._findFirst === true && typeof found === 'string') {
          return found;
        } else if (this._findFirst === true && found === null) {

        } else if (found.length > 0) {
          result = result.concat(found);
        }
        if (breakAtEnd) {
          break;
        }
        previous = parentPath;
      }
      if (this._findFirst === true) {
        return null;
      } else {
        return result;
      }
    };

    Base.prototype.getPathsFromParentsAsync = function(fn, mask, type) {
      var Finder, breakAtEnd, finder, finders, i, parentPath, parentPaths, previous, result, _i, _len,
        _this = this;
      if (mask == null) {
        mask = null;
      }
      if (type == null) {
        type = 'all';
      }
      Finder = require('./Finder');
      parentPaths = Helpers.expandPath(this.directory);
      result = [];
      previous = null;
      breakAtEnd = false;
      finders = [];
      for (i = _i = 0, _len = parentPaths.length; _i < _len; i = ++_i) {
        parentPath = parentPaths[i];
        if (this.up === true) {

        } else if (typeof this.up === 'string' && this.up === parentPath) {
          breakAtEnd = true;
        } else if (typeof this.up === 'number' && this.up <= i) {
          break;
        }
        finder = new Finder(parentPath);
        finder.recursive = this.recursive;
        finder.excludes = this.excludes;
        finder.filters = this.filters;
        finder.systemFiles = this.systemFiles;
        finder._findFirst = this._findFirst === true;
        if (previous !== null) {
          finder.exclude(previous, true);
        }
        finders.push(finder);
        if (breakAtEnd) {
          break;
        }
        previous = parentPath;
      }
      return async.eachSeries(finders, function(finder, cb) {
        return finder.getPathsAsync(function(found) {
          if (_this._findFirst === true && typeof found === 'string') {
            fn(found);
            return cb(new Error('Fake error'));
          } else if (_this._findFirst === true && found === null) {
            return cb();
          } else {
            result = result.concat(found);
            return cb();
          }
        }, type, mask);
      }, function(err) {
        if (!err) {
          return fn(_this._findFirst === true ? null : result);
        }
      });
    };

    return Base;

  })();

  module.exports = Base;

}).call(this);
